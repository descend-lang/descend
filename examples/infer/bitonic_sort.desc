
fn bitonicsort<n: nat, a: prv>(ha_array: &a uniq cpu.mem [i32; n])-[cpu.thread]->(){
    let mut gpu =gpu_device(0);
    let mut a_array = gpu_alloc_copy(&uniq gpu, &shrd *ha_array);
    let view_a = to_view(a_array);
    for_nat k in doubled_range(2,(n/2)) {

        for_nat j in halved_range(k/2){

             exec::<(n/(2*BLOCK_SIZE)),BLOCK_SIZE>(a_array,|grid,array|-[gpu.grid]->() {

                                                                                     //[T;n]
                let j_group = group_mut::< j > (view_a);                             //[[T;j];n/j]
                let j_group_t = transpose(j_group);                                  //[[T;n/j];j]
                let joined = join(j_group_t);                                        //[T;n]
                let pair = group_mut::< 2 > (j_group);                               //[[T;2];n/2]

                let grouped_pairs = group_mut::< (k/j) > (pair);                     //[[[T;2];k/j];n*j/2k]
                let grouped_pairs_t = transpose(grouped_pairs);                      //[[[T;2];n*j/2k];k/j]
                let splitted = split uniq k / (2 * j) grouped_pairs_t;       //([[[T;2];n*j/2k];k/2j],[[[T;2];n*j/2k];k/2j])
                let ascending = join(splitted.0);                                    //([[T;2];n/4],[[T;2];n/4])
                let descending = join(splitted.1);

                let asc_blocks = group_mut::<BLOCK_SIZE> (ascending);
                let desc_blocks = group_mut::<BLOCK_SIZE> (descending);

                let num_blocks: i32 = n/2*BLOCK_SIZE;

                let (even_blocks, odd_blocks) =split_blocks::<(num_blocks/2)>(join(transpose(group::<2>(all_blocks))));


                parfor block in even_blocks with elems from asc_blocks{
                    parfor thread in block with pair from elems{
                        if pair[0]>pair[1]{
                            let temp = pair[0];
                            pair[0] = pair[1];
                            pair[1] = temp
                        }
                    }
                };

                parfor block in odd_blocks with elems from desc_blocks{
                    parfor thread in block with pair from elems{
                        if pair[0]<pair[1]{
                            let temp = pair[0];
                            pair[0] = pair[1];
                            pair[1] = temp
                        }
                    }
                }

             })
        }
    };

    for_nat j in halved_range(n/2){
        exec::<(n/(2*BLOCK_SIZE)),BLOCK_SIZE>(a_array,|grid,array|-[gpu.grid]->(){
            let j_group = group_mut::< j > (view_a);                             //[[T;j];n/j]
            let j_group_t = transpose(j_group);                                  //[[T;n/j];j]
            let joined = join(j_group_t);                                        //[T;n]
            let pairs = group_mut::< 2 > (j_group);                              //[[T;2];n/2]
            parfor block in grid with pair from pairs{
                if pair[0] > pair[1]{
                    let temp = pair[0];
                    pair[0] = pair[1];
                    pair[1] = temp
                }
            }
        })
    };
    copy_to_host(&shrd a_array, ha_array)
}