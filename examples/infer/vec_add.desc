fn vector_add<gs: nat, bs: nat>(
    h_vec_a: &uniq cpu.mem [u32; gs*bs],
    h_vec_b: &shrd cpu.mem [u32; gs*bs]
) -[t: cpu.thread]-> () {
    let mut gpu = gpu_device(0);
    let mut g_vec_a = gpu_alloc_copy(&uniq gpu, &shrd *h_vec_a);
    let g_vec_b = gpu_alloc_copy(&uniq gpu, &shrd *h_vec_b);
    vector_add_gpu::<<<X<gs>, X<bs>>>>(&uniq g_vec_a, &shrd g_vec_b);
    copy_to_host(&shrd g_vec_a, h_vec_a)
}

fn vector_add_gpu<gs: nat, bs: nat, a: prv, b: prv>(
    g_vec_a: &a uniq gpu.global [u32; gs*bs],
    g_vec_b: &b shrd gpu.global [u32; gs*bs]
)  -[grid: gpu.grid<X<gs>, X<bs>>]-> () {
    let view_a = group_mut::<bs>(to_view_mut(g_vec_a));
    let view_b = group::<bs>(to_view(g_vec_b));
    sched block in grid {
        let a_row = view_a[[block]];
        let b_row = view_b[[block]];
        sched thread in block {
            let a = a_row[[thread]];
            let b = b_row[[thread]];
            *a = *a + *b
        }
    }
}
