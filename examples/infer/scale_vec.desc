//let x: D
//D: dty in <> -> Datentyp

//let reference: &'a mut i32 -- Rust reference reference
//let dref: &r w m d -- Descend reference type
//r = lifetime(r) | ident -- Lifeimtes, then variable ident: prv
//w = uniq | shrd -> entpsricht mut -- Uniqueness, unique -> kein Duplikate, einmalig dort
// m = cpu.mem | gpu.global | gpu.local | ident -- Memory, then ident: mem
//d = i32 | f64 | ... | ident --Datentyp, then ident:dty
// Rückgabe: host -> cpu.thread in [] wo das augeführt werden soll
//exec (execution ressource) = cpu.thread | gpu.grid | gpu.block | gpu.thread

fn scale_vec<n: nat, r: prv>(
    h_vec: &r uniq cpu.mem [f64; n]
) -[t: cpu.thread]-> () {
    let mut gpu = gpu_device(0);
    let mut a_array = gpu_alloc_copy(&uniq gpu, &shrd *h_vec);
    par_scale_vec::<<<X<64>, X<1024>>>>(&uniq a_array);
    copy_to_host(&shrd a_array, h_vec)
}

fn par_scale_vec<n: nat, r: prv>(
    vec: &r uniq gpu.global [f64; n]
) -[grid: gpu.grid<X<64>, X<1024>>]-> () {
    sched block in grid {
        sched thread in block {
            let v = &uniq (*vec).to_view.grp::<1024>.map(rev::<1024>)[[block]][[thread]];
            *v = *v * 3.0
        }
    }
}
