fn reduce_shared_mem<gs: nat, bs: nat, a: prv, b: prv>(
    ha_array: &a shrd cpu.mem [i32; gs*bs],
    h_output: &b uniq cpu.mem [i32; gs]
) -[t: cpu.thread]-> () {
    let mut gpu = gpu_device(0);

    let a_array = gpu_alloc_copy(&uniq gpu, ha_array);
    let mut out_array = gpu_alloc_copy(&uniq gpu, &shrd *h_output);
    exec::<gs, bs>(
        &uniq gpu,
        (&shrd a_array, &uniq out_array),
        | inputs: (&shrd gpu.global [i32; gs*bs],
          &uniq gpu.global [i32; gs])| -[grid: gpu.grid<X<64>, X<1024>>]-> () {
            let block_group = group::<1024>(to_view(inputs.0));
            let view_out = group_mut::<1>(to_view_mut(inputs.1));
            // TODO remove decl and move out tmp declaration
            let mut tmp: [i32; bs] @ gpu.shared;
            sched block in grid {
                let ib = block_group[[block]];
                let out_elem = view_out[[block]];
                let tmp_view = to_view_mut(&uniq tmp);
                sched thread in block {
                    let inp = ib[[thread]];
                    let tmp_in = tmp_view[[thread]];
                    *tmp_in = *inp
                };

                for_nat k in halved_range(bs/2) {
                    let tmp_view = to_view_mut(&uniq tmp);
                    let split_tmp_view = (split uniq 2*k (*tmp_view)).0;
                    let active_halves = split uniq k (*split_tmp_view);

                    let active_half0 = active_halves.0;
                    let active_half1 = active_halves.1;

                    // Fixme: At this point 's1 -> {tmp, split_tmp_view, tmp_view, tmp}
                    indep(X) k block {
                        active =>
                            sched thread in active {
                                let a = active_half0[[thread]];
                                let b = active_half1[[thread]];
                                *a = *a + *b
                            },
                        inactive => { () }
                    }
                };
                let tmp_view2 = to_view_mut(&uniq tmp);
                let tmp_res = (split uniq 1 (*tmp_view2)).0;
                indep(X) 1 block {
                    single_thread =>
                        sched thread in single_thread {
                            let out = out_elem[[thread]];
                            let tmp_val = tmp_res[[thread]];
                            *out = *tmp_val
                        },
                    rest => { () }
                }
            }
        }
    );
    copy_to_host(&shrd out_array, &uniq *h_output);
    let mut res = 0;
    for x in h_output {
        res = res + *x
    }
}