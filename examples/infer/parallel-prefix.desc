/*
 * Naming stuff is hard:
 * - cpu_    prefix is memory in the cpu
 * - g_      prefix is global memory
 * - gi_     prefix is global memory inside the exec
 * - b_      prefix is for block memory
 * - shared_ prefix is shared memory inside a block
 * - view_   preifx(or suffix) is a view of the following
 * - t_      prefix is inside a parfor per thread
 */

fn prefix_scan(
    // TODO global fun params into same frame as top level declaration in body
    cpu_i_array: &uniq cpu.mem [i32; 64 * 1024 * 2],
    cpu_flag_array: &uniq cpu.mem [i32; 64],
    cpu_agg_array: &uniq cpu.mem [i32; 64],
    cpu_prefix_array: &uniq cpu.mem [i32; 64]
) -[cpu.thread]-> () {
    let mut gpu = gpu_device(0);

    let mut g_i = gpu_alloc_copy(&uniq gpu, &shrd *cpu_i_array);
    let mut g_flags = gpu_alloc_copy(&uniq gpu, &shrd *cpu_flag_array);
    let mut g_aggs = gpu_alloc_copy(&uniq gpu, &shrd *cpu_agg_array);
    let mut g_prefixs = gpu_alloc_copy(&uniq gpu, &shrd *cpu_prefix_array);
    exec::<64, 1024>(
        &uniq gpu,
        (
            &uniq g_i, 
            &uniq g_flags,
            &uniq g_aggs,
            &uniq g_prefixs
        ),
        | grid: BlockGrp<64, ThreadGrp<1024>>,
          input: (
              &uniq gpu.global [i32; 64 * 1024 * 2],
              &uniq gpu.global [i32; 64],
              &uniq gpu.global [i32; 64],
              &uniq gpu.global [i32; 64]
          )
        | -[gpu.grid]-> () {
            // TODO deconstruction works
            let gi_i = input.0;
            let gi_flags = input.1;
            let gi_aggs = input.2;
            let gi_prefixs = input.3;
            let view_input = group_mut::<2048>(to_view_mut(gi_i));
            let view_aggs = group_mut::<1>(to_view_mut(gi_aggs));
            let view_flags = group_mut::<1>(to_view_mut(gi_flags));
            // let view_flags = to_view_mut(gi_flags);
            let view_prefix = group_mut::<1>(to_view_mut(gi_prefixs));
            decl {
                let mut shared_input: [i32; 1024 * 2] @ gpu.shared;
                // let mut tmp2: [i32; 1024 * 2] @ gpu.shared;
                let mut result_reduction: [i32; 1024] @ gpu.shared;
                let mut exclusive_prefix: [i32; 1] @ gpu.shared;
                let mut last_value: [i32; 1] @ gpu.shared
            } parfor block in grid 
                with b_input, b_agg, b_flag, b_prefix from view_input, view_aggs, view_flags, view_prefix {
                // Copy into shared
                let mut shared_input_view = group_mut::<2>(to_view_mut(& uniq shared_input));
                let mut result_view = to_view_mut(&uniq result_reduction);
                let mut view_exclusive_prefix = to_view_mut(&uniq exclusive_prefix);
                let mut view_last_value = to_view_mut(&uniq last_value);
                let group_input = group_mut::<2>(b_input);
                parfor thread in block
                with t_shared_input, t_input from
                    &uniq *shared_input_view, &uniq *group_input {
                    t_shared_input[0] = t_input[0];
                    t_shared_input[1] = t_input[1]
                };

                parfor thread in block
                with t_shared_input, r from &uniq *shared_input_view, &uniq *result_view {
                    *r = t_shared_input[0] + t_shared_input[1]
                };

                // borrowed from tree_reduce
                for_nat k in halved_range(512) {
                   let split_ib = (split uniq 2*k (*result_view)).0;
                   let (active_half0, active_half1) = split uniq k (*split_ib);

                   parfor thread in split_thread_grp::<k, 1024, 1, 1>(block).0
                   with fst_half, snd_half from active_half0, active_half1 {
                       *fst_half = *fst_half + *snd_half
                   }
                };

                parfor thread in split_thread_grp::<1>(block).0
                // This feels wrong...
                with t_r, t_agg from &uniq *result_view, &uniq *b_agg {
                    *t_agg = *t_r
                };
                // Cheesy Threadfence
                // This feels wrong...
                parfor thread in split_thread_grp::<1>(block).0
                with t_flag from &uniq *b_flag {
                    *t_flag = 1
                };

                parfor thread in split_thread_grp::<1>(block).0
                with t_exclusive_prefix from &uniq *view_exclusive_prefix {
                let unsafe_code_block_marker = 0
                // *t_exclusive_prefix = 0
                // unsafe code block
                /* 
                  inline_cuda {
                      if (blockIdx.x > 0) {
                        bool done = false;
                        // WINDOW
                        int end_index = blockIdx.x - 5;
                        if (end_index < 0) end_index = 0;
                        exclusive_prefix[0] = 0;
                        while (!done) {
                            int i = blockIdx.x - 1;
                            while (i >= 0) {
                                int flag = gi_flags[i];
                                // printf("flag: %d\n", flag);
                                if (flag == 0) {
                                    break;
                                } else if (flag == 1) {
                                    exclusive_prefix[0] = exclusive_prefix[0] + gi_aggs[i];
                                } else if (flag == 2) {
                                    exclusive_prefix[0] = gi_prefixs[i] + exclusive_prefix[0];
                                    done = true;
                                    break;
                                }
                                i--;
                            }
                        }
                      }
                  }
                */
                };
                // Is this possible without with block? I do not need it?
                parfor thread in split_thread_grp::<1>(block).0
                with t_r, t_prefix, t_exclusive_prefix from &uniq *result_view, &uniq *b_prefix, &shrd *view_exclusive_prefix  {
                    *t_prefix = *t_exclusive_prefix + *t_r
                };
                // Cheesy Threadfence
                parfor thread in split_thread_grp::<1>(block).0
                with t_flag from &uniq *b_flag {
                    *t_flag = 2
                };

                let tmp_view2 = to_view_mut(&uniq shared_input);
                let tmp_last = (split uniq 2047 (*tmp_view2)).1;
                parfor _ in split_thread_grp::<1>(block).0
                with last, t_last_bkp from &uniq *tmp_last, &uniq *view_last_value
                {
                    *t_last_bkp = *last
                };

                upsweep(block, &uniq shared_input);
                parfor _ in split_thread_grp::<1>(block).0
                with last, t_last_bkp from &uniq *tmp_last, &uniq *view_last_value
                {
                    *last = *t_last_bkp
                };
                downsweep(block, &uniq shared_input);
                parfor thread in block
                with t_tmp, t_input, t_exclusive_prefix from &uniq *shared_input_view, group_input, &uniq *view_exclusive_prefix   {
                    // Workaround for *exclusive_prefix in 2 following lines
                    t_input[0] = t_tmp[0] + *t_exclusive_prefix;
                    t_input[1] = t_tmp[1] + *t_exclusive_prefix
                }
            }
        }
    );
    copy_to_host(&shrd g_i, cpu_i_array);
    copy_to_host(&shrd g_flags, cpu_flag_array);
    copy_to_host(&shrd g_aggs, cpu_agg_array);
    copy_to_host(&shrd g_prefixs, cpu_prefix_array)
}

fn upsweep(
    thread_grp: ThreadGrp<1024>,
    arr_ref: &uniq gpu.shared [i32; 2048]
) -[gpu.block]-> () <>{
    for_nat d in halved_range(1024) <'a>{
        let tmp_up_view = group_mut::<2048/d, 'a, gpu.shared, 2048, i32>(
            to_view_mut(&uniq *arr_ref));
        parfor _ in split_thread_grp::<d>(thread_grp).0
        with arr from tmp_up_view
        { arr[2048/d-1] = arr[2048/d-1] + arr[1024/d-1] }
    }
}

fn downsweep(
    block: ThreadGrp<1024>,
    arr_ref: &uniq gpu.shared [i32; 2048]
) -[gpu.block]-> () <>{
    for_nat d in doubled_range(1, 1024) <'b>{
        let tmp_down_view = group_mut::<2048 / d, 'b, gpu.shared, 2048, i32>(
            to_view_mut::<'b, gpu.shared, 2048, i32 > (&'b uniq *arr_ref));
        parfor _ in split_thread_grp::<d, 1024, 1, 1> (block).0
        with arr from tmp_down_view
        {
            let t = arr[1024/d-1];
            arr[1024/d-1] = arr[2048/d-1];
            arr[2048/d-1] = arr[2048/d-1] + t
        }
    }
}
