struct HChange<T> {
    mask: bool,
    updatingMask: bool,
    visited: bool,
    cost: T
}

struct Node {
    start: i32,
    number_ofEdges: i32
}
impl Copy for Node {}

trait Incrementable: Copy {
    fn increment(Self) -[gpu.thread]-> Self;
}

impl Incrementable for i32 {
    fn increment(self) -[gpu.thread]-> Self {
        self + 1
    }
}

fn iteration<m: nat, T>(
    nod2: &shrd gpu.global Node,
    chgn2: &uniq gpu.global HChange<T>,
    ed2: &shrd gpu.global [i32; m]
) -[gpu.thread]-> () where T: Incrementable {
    let nodes2 = *nod2;
    if (*chgn2).mask {
        (*chgn2).mask = false;

        let upper_range = nodes2.start + nodes2.number_ofEdges;
        for i in nodes2.start..upper_range {
            let change_ptr = to_raw_ptr(&uniq *chgn2);
            let ch_ptr_i = offset_raw_ptr(change_ptr, ed2[i]);

            if !(*ch_ptr_i).visited {
                (*ch_ptr_i).cost = (*chgn2).cost.increment();
                (*ch_ptr_i).updatingMask = true
            }
        }
    }
}

fn bfs<n:nat, m:nat>(
    h_nodes: &shrd cpu.mem [Node; n],
    h_edges: &shrd cpu.mem [i32; m],
    h_changes: &uniq cpu.mem [HChange<i32>; n],
    h_stop: &uniq cpu.mem bool
) -[cpu.thread]-> () {
    let prepare_iteration = |change3, stop3| -[gpu.thread]-> () {
        if (*change3).updatingMask {
            (*change3).mask = true;
            (*change3).visited = true;
            atomic_set(stop3, true);
            (*change3).updatingMask = false
        }
    };

    let mut gpu = gpu_device(0);
    let mut stop = gpu_alloc_copy(&uniq gpu, &shrd *h_stop);
    let nodes = gpu_alloc_copy(&uniq gpu, h_nodes);
    let edges = gpu_alloc_copy(&uniq gpu, h_edges);
    let mut d_changes = gpu_alloc_copy(&uniq gpu, &shrd *h_changes);

    while *h_stop {
        *h_stop = false;
        copy_to_gpu(&uniq stop, &shrd *h_stop);

        let nodes_view = to_view(&shrd nodes);
        let view_changes = to_view_mut(&uniq d_changes);

        let grouped_nodes = group::<16>(nodes_view);
        let grouped_changes = group_mut::<16>(view_changes);

        //kernel 1
        exec::<4, 16>(
            &uniq gpu,
            (grouped_nodes, grouped_changes, &shrd edges),
            | grid, input | -[gpu.grid]-> () {
                let (nod_view, chgn_view) = (input.0, input.1);
                let edg = input.2;

                parfor block in grid with nod, chgn from nod_view, chgn_view {
                    parfor _ in block with nod2, chgn2 from nod, chgn {
                        iteration(nod2, chgn2, edg)
                    }
                  }
            }
        );

        let view_changes2 = to_view_mut(&uniq d_changes);
        let grouped_changes2 = group_mut::<16>(view_changes2);

        // kernel 2
        exec::<4, 16>(
            &uniq gpu,
            (grouped_changes2, &uniq stop),
            | grid, input2 | -[gpu.grid]-> () {
                let changes = input2.0;
                let stop_temp = input2.1;

                parfor block in grid with change2 from changes {
                    parfor _ in block with change3 from change2 {
                        prepare_iteration(change3, stop_temp)
                    }
                }
            }
        );

        copy_to_host(&shrd stop, &uniq *h_stop)
    }
}