fn reduce<n: nat, a: prv, b: prv>(
  ha_array: &a uniq cpu.heap [i32; n]
) -[cpu.thread]-> () {
  letprov <'r, 's, 'c, 'd, 'e, 'f, 'i, 'g, 'h> {
    let gpu: Gpu = gpu_device(0);

    let mut a_array: [i32; n] @ gpu.global =
      gpu_alloc::<'c, 'd, cpu.stack, cpu.heap, [i32; n]>(&'c uniq gpu, &'d shrd *ha_array);
    let view_a: [[&'r uniq gpu.global i32; n]] =
      to_view_mut::<'r, gpu.global, n, i32>(&'r uniq a_array);
    let block_group = group::<1024, n, &'r uniq gpu.global i32>(view_a);
    // exec: <b: nat, t: nat, r: prv, m: mem, elem_ty: ty, n: nat>(
    //        &r uniq m Gpu, [[elem_ty; n]], ([[[[Thread; t]]; b]], [[elem_ty; n]]) -[gpu]-> ()) -> ()
    exec::<64, 1024, 'h, cpu.stack, [[[[&'r uniq gpu.global i32; 1024]]; 64]]>(
      &'h uniq gpu,
      block_group,
      | grid: Grid<Block<Thread, 1024>, 64>,
        input: [[[[&'r uniq gpu.global i32; 1024]]; 64]]| -[gpu.grid]-> () {

        for grid with <input> do
          | block: Block<Thread, 1024>,
            ib: [[&'r uniq gpu.global i32; 1024]] | -[gpu.block]-> () {

            for_nat k in halved_range(512) {
              let active_non_active = split_at::<2*k, 1024, &'r uniq gpu.global i32>(ib);
              let active_halves = split_at::<k, 2*k, &'r uniq gpu.global i32>(active_non_active.0);
              let active_non_active_threads = split::<k, 1024>(block);
              let active_threads = active_non_active_threads.0;
              for active_threads
              with <active_halves.0, active_halves.1>
              do
                | thread: Thread,
                  fst_half: &'r uniq gpu.global i32,
                  snd_half: &'r uniq gpu.global i32 | -[gpu.thread]-> () {
                    *fst_half = *fst_half + *snd_half;
                };
            }
        };
      }
    );

    copy_to_host::<'g, a, [i32; n]>(&'g shrd a_array, ha_array);
  }
}