fn store<r2: prv, i: prv, a8: prv>(
    change3: &i uniq gpu.global (bool, i32, bool, i32),
    a_st: &a8 uniq gpu.global Atomic<i32>
) -[gpu.thread]-> () {
    letprov<'a9, 'b5> {
        //let updated = load_atomic::<'b4, gpu.global>(&'b4 shrd *inp.1.1);
        let mut c = *change3;
        let updated = c.1;
        if updated != 0 {
            c.0 = true;
            c.2 = true;
            store_atomic::<'a9, gpu.global>(&'a9 shrd *a_st, 1);
            // *inp.1.1 = false;
            //store_atomic::<'b5, gpu.global>(&'b5 shrd (*change3).1, 0)
            (*change3).1 = 0
        } else {
            ()
        }
    }
}

fn bfs<n:nat, m:nat, a: prv, b: prv, k:prv, l:prv, a1:prv>(
    h_nodes: &a shrd cpu.heap [(i32, i32); n],
    h_edges: &b shrd cpu.heap [i32; m],
    h_changes: &k uniq cpu.heap [(bool, i32, bool, i32); n],
    h_atomic_stop: &a1 uniq cpu.heap Atomic<i32>
) -[cpu.thread]-> () {
    letprov<'c, 'd, 'e, 'f, 'g, 'h, 'a2, 'a3, 'a4>{
        let mut gpu: Gpu = gpu_device(0);
        let mut atomic_stop: Atomic<i32> @ gpu.global =
            gpu_alloc::<'a2, 'a3, cpu.stack, cpu.heap, Atomic<i32>>(&'a2 uniq gpu, &'a3 shrd *h_atomic_stop);
        let nodes: [(i32, i32); n] @ gpu.global = 
            gpu_alloc::<'c, 'd, cpu.stack, cpu.heap, [(i32, i32); n]>(&'c uniq gpu, &'d shrd *h_nodes);
        let edges: [i32; m] @ gpu.global =
            gpu_alloc::<'e, 'f, cpu.stack, cpu.heap, [i32; m]>(&'e uniq gpu, &'f shrd *h_edges);
        let mut d_changes: [(bool, i32, bool, i32); n] @ gpu.global =
            gpu_alloc::<'g, 'h, cpu.stack, cpu.heap, [(bool, i32, bool, i32); n]>(&'g uniq gpu, &'h shrd *h_changes);
        let stop_t = load_atomic_host::<'a4, cpu.heap>(&'a4 shrd *h_atomic_stop);
        while stop_t != 0 { // *h_stop
            letprov<'r1, 'r2, 'i, 'o, 'p, 't, 'q, 'j, 'k, 'v, 'm, 'n, 'o, 'u, 'x, 'a5, 'a6, 'a7, 'a8>{
                store_atomic_host::<'a5, cpu.heap>(&'a5 shrd *h_atomic_stop, 0);
                copy_to_gpu::<'a6, 'a7, Atomic<i32>>(&'a6 uniq atomic_stop, &'a7 shrd *h_atomic_stop);

                let nodes_view: &'r1 shrd gpu.global [[(i32, i32); n]] =
                    to_view::<'r1, gpu.global, n, (i32, i32)>(&'r1 shrd nodes);

                let view_changes: &'i uniq gpu.global [[(bool, i32, bool, i32); n]] =
                    to_view_mut::<'i, gpu.global, n, (bool, i32, bool, i32)>(&'i uniq d_changes);

                let grouped_nodes = group::<16, 'r1, gpu.global, n, (i32,i32)>(nodes_view);
                let grouped_changes = group_mut::<16, 'i, gpu.global, n, (bool, i32, bool, i32)>(view_changes);

                //kernel 1
                exec::<4 , 16, 'j, cpu.stack,
                        <&'r1 shrd gpu.global [[[[(i32, i32); 16]]; 4]],
                        &'i uniq gpu.global [[[[(bool, i32, bool, i32); 16 ]]; 4]],
                        &'k shrd gpu.global [i32; m]>>(
                    &'j uniq gpu,
                    <grouped_nodes, grouped_changes, &'k shrd edges>,
                    | grid: BlockGrp<4, ThreadGrp<16>>,  //  Grid<Block<Thread, 16>, 4>,
                      input: <&'r1 shrd gpu.global [[[[(i32, i32); 16]]; 4]],
                              &'i uniq gpu.global [[[[(bool, i32, bool, i32); 16 ]]; 4]],
                              &'k shrd gpu.global [i32; m]>
                    | -[gpu.grid]-> () {

                        let nod_view = input.0;
                        let chgn_view = input.1;
                        let edg = input.2;

                          for grid with <nod_view, chgn_view, edg> do

                            | block: ThreadGrp<16>,
                              nod: &'r1 shrd gpu.global [[(i32, i32); 16]],
                              chgn: &'i uniq gpu.global [[(bool, i32, bool, i32); 16]],
                              ed: &'k shrd gpu.global [i32; m]
                            | -[gpu.block]-> () {
                                for block with <nod, chgn, ed> do
                                    | node: &'r1 shrd gpu.global (i32, i32),
                                      change: &'i uniq gpu.global (bool, i32, bool, i32),
                                      e: &'k shrd gpu.global [i32; m]
                                    | -[gpu.thread]-> () {
                                        // FIXME what is happening here?
                                        let something = node;
                                        let anything = change;
                                        let temp_car = e // e[2]; // try to index into non array type
                                        // let something_else = ch
                                    }
                            }
                    }
                );

                let view_changes2: &'i uniq gpu.global [[(bool, i32, bool, i32); n]] =
                    to_view_mut::<'i, gpu.global, n, (bool, i32, bool, i32)>(&'i uniq d_changes);

                let grouped_changes2 = group_mut::<16, 'i, gpu.global, n, (bool, i32, bool, i32)>(view_changes2);

                // kernel 2
                exec::<4, 16, 'j, cpu.stack,
                       <&'i uniq gpu.global [[[[(bool, i32, bool, i32); 16 ]]; 4]],
                        &'a8 uniq gpu.global Atomic<i32>>>(
                    &'j uniq gpu,
                    <grouped_changes2, &'a8 uniq atomic_stop>,
                    | grid:  BlockGrp<4, ThreadGrp<16>>,
                      input2: <&'i uniq gpu.global [[[[(bool, i32, bool, i32); 16 ]]; 4]], &'a8 uniq gpu.global Atomic<i32>>
                    | -[gpu.grid]-> () {
                            let changes = input2.0;
                            let a_stop_temp = input2.1;
                            for grid with <changes, a_stop_temp> do
                            | block: ThreadGrp<16>,
                                chngs2: &'i uniq gpu.global [[(bool, i32, bool, i32); 16]],
                                a_stop2: &'a8 uniq gpu.global Atomic<i32>
                            | -[gpu.block]-> () {
                                for block with <chngs2, a_stop2>
                                do store::<'r2, 'i, 'a8>
                            }
                        }
                    );
                // copy_to_host::<'u, 'x, cpu.heap, bool>(&'u shrd d_stop,&'x uniq *h_stop);
                copy_to_host::<'u, 'x, cpu.heap, Atomic<i32>>(&'u shrd atomic_stop, &'x uniq *h_atomic_stop)
            }
        }
    }
}