fn inplace_vector_add<n: nat, 'a: prv, 'b: prv>(
  ha_array: &'a uniq cpu.heap [i32; n],
  hb_array: &'b shrd cpu.heap [i32; n]
) -[cpu.thread]-> ()
  letprov <a, b, c, d, e, f, g, h> {
    let gpu: Gpu = gpu(/* GPU info */);

    let mut a_array: [i32; n] @ gpu.global = gpu_alloc<c, 'a, [i32; n]>(&c uniq gpu, ha_array);
    let b_array: [i32; n] @ gpu.global = gpu_alloc<[i32; n]>(&d uniq gpu, hb_array);

    let view_a: [[&a uniq gpu.global i32; n]] =
      to_view<a, uniq, gpu.global, n, i32>(&a uniq a_array);
    let view_b: [[&b shrd gpu.global i32; n]] =
      to_view<b, shrd, gpu.global, n, i32>(&b shrd b_array);
    let elems: [[(&a uniq gpu.global i32, &b shrd gpu.global i32); n]] =
      zip<n, &a uniq i32, &b shrd i32>(view_a, view_b);
    let grid: GridConfig<64, 1024> = spawn_threads<64, 1024, h>(&h shrd gpu)
    // hoisted runtime check: n == 64 * 1024
    for (a, b) in elems across grid {
      *a = *a + *b;
    } //sync()
    copy_to_host<g, 'a, [i32; n]>(&g shrd a_array, ha_array);
  }
}