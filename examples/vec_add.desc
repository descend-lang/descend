fn add<r: prv, s: prv>(
    inp: <&r uniq gpu.global i32, &s shrd gpu.global i32>
) -[gpu.thread]-> () {
    *inp.0 = *inp.0 + *inp.1;
}

fn inplace_vector_add<n: nat, a: prv, b: prv>(
    ha_array: &a uniq cpu.stack [i32; n],
    hb_array: &b shrd cpu.stack [i32; n]
) -[cpu.thread]-> () {
    letprov <'r, 's, 'c, 'd, 'e, 'f, 'i, 'g, 'h> {
        let mut gpu: Gpu = gpu_device(0);

        let mut a_array: [i32; n] @ gpu.global =
            gpu_alloc::<'c, 'd, cpu.stack, cpu.stack, [i32; n]>(&'c uniq gpu, &'d shrd *ha_array);
        let b_array: [i32; n] @ gpu.global =
            gpu_alloc::<'f, 'i, cpu.stack, cpu.stack, [i32; n]>(&'f uniq gpu, &'i shrd *hb_array);
        let view_a: [[&'r uniq gpu.global i32; n]] =
            to_view_mut::<'r, gpu.global, n, i32>(&'r uniq a_array);
        let view_b: [[&'s shrd gpu.global i32; n]] =
            to_view::<'s, gpu.global, n, i32>(&'s shrd b_array);
        let elems: [[<&'r uniq gpu.global i32, &'s shrd gpu.global i32>; n]] =
            zip::<n, &'r uniq gpu.global i32, &'s shrd gpu.global i32>(view_a, view_b);
        let grouped_elems: [[[[<&'r uniq gpu.global i32, &'s shrd gpu.global i32>; 1024]]; n/1024]] =
            group::<1024, n, <&'r uniq gpu.global i32, &'s shrd gpu.global i32>>(elems);
        // exec: <b: nat, t: nat, r: prv, m: mem, elem_ty: ty, n: nat>(
        //        &r uniq m Gpu, [[elem_ty; n]], ([[[[Thread; t]]; b]], [[elem_ty; n]]) -[gpu]-> ()) -> ()
        exec::<64, 1024, 'h, cpu.stack, [[[[<&'r uniq gpu.global i32, &'s shrd gpu.global i32>; 1024]]; 64]]>(
            &'h uniq gpu,
            grouped_elems,
            | grid: BlockGrp<64, ThreadGrp<1024>>,
              input: [[[[<&'r uniq gpu.global i32, &'s shrd gpu.global i32>; 1024]]; 64]]
            | -[gpu.grid]-> () {
                for grid with <input> do
                    | block: ThreadGrp<1024>,
                      ib: [[<&'r uniq gpu.global i32, &'s shrd gpu.global i32>; 1024]]
                    | -[gpu.block]-> () {
                         for block with <ib> do add::<'r, 's>
                    };
            }
        );
        copy_to_host::<'g, a, cpu.stack, [i32; n]>(&'g shrd a_array, ha_array);
    }
}
