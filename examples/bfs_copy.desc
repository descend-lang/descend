fn bfs<n:nat, m:nat, a: prv, b: prv, k:prv, l:prv, a1:prv>(
    h_nodes: &a shrd cpu.heap [(i32, i32); n],
    h_edges: &b shrd cpu.heap [i32; m],
    h_changes: &k uniq cpu.heap [(bool, Atomic<i32>, bool, Atomic<i32>); n],
    h_atomic_stop: &a1 uniq cpu.heap Atomic<i32>
) -[cpu.thread]-> () {
    letprov<'c, 'd, 'e, 'f, 'r1, 'r2, 's, 'g, 'h, 'i, 'o, 'p, 't, 'q, 'j, 'k, 'u, 'v, 'm, 'n, 'o, 
        'x, 'a2, 'a3, 'a4, 'a5, 'a6, 'a7, 'a8, 'a9, 'b1, 'b2, 'b3, 'b4, 'b5>{

        let gpu: Gpu = gpu_device(0);
        let atomic_stop: Atomic<i32> @ gpu.global =
            gpu_alloc::<'a2, 'a3, cpu.stack, cpu.heap, Atomic<i32>>(&'a2 uniq gpu, &'a3 shrd *h_atomic_stop);
        let nodes: [(i32, i32); n] @ gpu.global = 
            gpu_alloc::<'c, 'd, cpu.stack, cpu.heap, [(i32, i32); n]>(&'c uniq gpu, &'d shrd *h_nodes);
        let edges: [i32; m] @ gpu.global =
            gpu_alloc::<'e, 'f, cpu.stack, cpu.heap, [i32; m]>(&'e uniq gpu, &'f shrd *h_edges);
        let mut d_changes: [(bool, Atomic<i32>, bool, Atomic<i32>); n] @ gpu.global = 
            gpu_alloc::<'g, 'h, cpu.stack, cpu.heap, [(bool, Atomic<i32>, bool, Atomic<i32>); n]>(&'g uniq gpu, &'h shrd *h_changes);
        let stop_t: i32 = load_atomic_host::<'a4, cpu.heap>(&'a4 shrd *h_atomic_stop);
        while stop_t != 0 {
            store_atomic_host::<'a5, cpu.heap>(&'a5 shrd *h_atomic_stop, 0);
            copy_to_gpu::<'a6, 'a7, Atomic<i32>>(&'a6 uniq atomic_stop, &'a7 shrd *h_atomic_stop);

            let nodes_view: [[ &'r1 shrd gpu.global (i32, i32); n]] =
                to_view::<'r1, gpu.global, n, (i32, i32)>(&'r1 shrd nodes);

            let view_changes: [[ &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>); n]] =
                to_view_mut::<'i, gpu.global, n, (bool, Atomic<i32>, bool, Atomic<i32>)>(&'i uniq d_changes);

            let zipped_nodes_changes: [[ <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>) >; n ]] =
                zip::<n, &'r1 shrd gpu.global (i32, i32), &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>) >(nodes_view, view_changes);
        
            let grouped_nodes_changes: [[ [[ <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>) >; 16 ]]; n/16]] =
                group::<16, n, <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>)> >(zipped_nodes_changes);
            //kernel 1
            exec::< 4 , 16, 'j, cpu.stack,  <[[ [[ <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>) >; 16 ]]; 4]],
                                                &'k shrd gpu.global [i32; m],
                                                &'n uniq gpu.global [(bool, bool, bool, i32); n] >
                                                >(
                &'j uniq gpu,
                <grouped_nodes_changes, &'k shrd edges, &'n uniq d_changes>,
                | grid: BlockGrp<4, ThreadGrp<16>>,  //  Grid<Block<Thread, 16>, 4>,
                  input: <[[ [[ <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>) >; 16 ]]; 4]],
                         &'k shrd gpu.global [i32; m],
                         &'n uniq gpu.global [(bool, bool, bool, i32); n]>
                | -[gpu.grid]-> () {

                    let nod_view = input.0;
                    let edg = input.1;
                    let all_changes = input.2;

                      for grid with <nod_view, edg, all_changes> do

                        | block: ThreadGrp<16>, 
                          ib: [[ <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>) >; 16 ]] ,
                          ed: &'k shrd gpu.global [i32; m],
                          all_ch: &'n uniq gpu.global [(bool, Atomic<i32>, bool, Atomic<i32>); n]
                        | -[gpu.block]-> () {
                            for block with <ib, ed, all_ch> do 
                                |  inp: <&'r1 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, Atomic<i32>, bool, Atomic<i32>)>,
                                  e: &'k shrd gpu.global [i32; m], 
                                  ch: &'n uniq gpu.global [(bool, Atomic<i32>, bool, Atomic<i32>); n]
                                | -[gpu.thread]-> () {
                                    if *inp.1.0 {
                                        *inp.1.0 = false;
                                        let node_start = *inp.0.0;
                                        let no_of_edges = *inp.0.1;
                                        for i in node_start..node_start+no_of_edges {
                                            let id: i32 = e[i];
                                            if !ch[i].2 {
                                                // ch[i].3 = *inp.1.3 + 1;
                                                let cost_new: i32 = load_atomic::<'b1, gpu.global>(&'b1 shrd *inp.1.3) + 1;
                                                store_atomic::<'b2, gpu.global>(&'b2 shrd *ch[i].3, cost_new);
                                                // ch[i].1 = true;
                                                store_atomic::<'b3, gpu.global>(&'b3 shrd *ch[i].1) = 1;
                                            } else {
                                                ()
                                            }
                                        }
                                    } else {
                                        ()
                                    }
                                    ()
                                };
                        };
                }
            );
            let nodes_view2: [[ &'r2 shrd gpu.global (i32, i32); n]] =
                to_view::<'r2, gpu.global, n, (i32, i32)>(&'r2 shrd nodes);

            let view_changes2: [[ &'i uniq gpu.global (bool, bool, bool, i32); n]] =
                to_view_mut::<'i, gpu.global, n, (bool, bool, bool, i32)>(&'i uniq d_changes);

            let zipped_nodes_changes2: [[ <&'r2 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; n ]] =
                zip::<n, &'r2 shrd gpu.global (i32, i32), &'i uniq gpu.global (bool, bool, bool, i32) >(nodes_view2, view_changes2);
        
            let grouped_nodes_changes2: [[ [[ <&'r2 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 16 ]]; n/16]] =
                group::<16, n, <&'r2 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32)> >(zipped_nodes_changes2);
            // kernel 2 
            exec::<4, 16, 'j, cpu.stack, 
                    <[[ [[ <&'r2 shrd gpu.global (i32, i32),  
                    &'i uniq gpu.global (bool, bool, bool, i32) >; 16 ]]; 4]], 
                    &'a8 uniq gpu.global Atomic<i32>>
                >(
                &'j uniq gpu,
                <grouped_nodes_changes2, &'a8 uniq atomic_stop>,
                | grid:  BlockGrp<4, ThreadGrp<16>>, 
                    input2: <[[ [[ <&'r2 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 16 ]]; 4]],
                    &'a8 uniq gpu.global Atomic<i32>>
                | -[gpu.grid]-> () {
                        let changes2 = input2.0;
                        let a_stop_temp = input2.1;
                        for grid with <changes2, a_stop_temp> do
                        | block: ThreadGrp<16>, 
                            ib2: [[ <&'r2 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 16 ]],
                            a_stop: &'a8 uniq gpu.global Atomic<i32>
                        | -[gpu.block]-> () {
                            for block with <ib2, a_stop> do
                                |    inp: <&'r2 shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >,
                                    a_st: &'a8 uniq gpu.global Atomic<i32>
                                | -[gpu.thread]-> () {
                                    let updated = load_atomic::<'b4, gpu.global>(&'b4 shrd *inp.1.1);
                                    if updated != 0 {
                                        *inp.1.0 = true;
                                        *inp.1.2 = true;
                                        store_atomic::<'a9, gpu.global>(&'a9 shrd *a_st, 1);
                                        // *inp.1.1 = false;
                                        store_atomic::<'b5, gpu.global>(&'b5 shrd *inp.1.1, 0);
                                    } else {
                                        ()
                                    }
                                };
                            };
                    }
                );
            copy_to_host::<'u, 'x, cpu.heap, Atomic<i32>>(&'u shrd atomic_stop, &'x uniq *h_atomic_stop);
        }
    }
}