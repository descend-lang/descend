fn bfs<n:nat, m:nat, a: prv, b: prv, k:prv, l:prv>(
    h_nodes: &a shrd cpu.heap [(i32, i32); n],
    h_edges: &b shrd cpu.heap [i32; m],
    h_changes: &k uniq cpu.heap [(bool, bool, bool, i32); n],
    h_stop: &l uniq cpu.heap bool
) -[cpu.thread]-> () {
    letprov<'c, 'd, 'e, 'f, 'r, 's, 'g, 'h, 'i, 'o, 'p, 't, 'q, 'j, 'u, 'v, 'm, 'n, 'o>{

        let gpu: Gpu = gpu_device(0);
        let nodes: [(i32, i32); n] @ gpu.global = 
            gpu_alloc::<'c, 'd, cpu.stack, cpu.heap, [(i32, i32); n]>(&'c uniq gpu, &'d shrd *h_nodes);
        let edges: [i32; m] @ gpu.global =
            gpu_alloc::<'e, 'f, cpu.stack, cpu.heap, [i32; m]>(&'e uniq gpu, &'f shrd *h_edges);
        let mut d_changes: [(bool, bool, bool, i32); n] @ gpu.global = 
            gpu_alloc::<'g, 'h, cpu.stack, cpu.heap, [(bool, bool, bool, i32); n]>(&'g uniq gpu, &'h shrd *h_changes);
        let mut d_stop: bool @ gpu.global =
            gpu_alloc::<'o, 'p, cpu.stack, cpu.heap, bool>(&'o uniq gpu, &'p shrd *h_stop);
        while *h_stop {

        
        let grouped_nodes_changes: [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; n/1024]] =
            group::<1024, n, <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32)> >(zipped_nodes_changes);

            // copy_to_gpu::<r: prv, r2: prv, r3: prv, t: ty>(&r uniq cpu.stack Gpu, & r2 uniq gpu.global t, & r3 shrd cpu.heap t): 
            copy_to_gpu::<'m, 't, 'q, bool>(&'m uniq gpu, &'t uniq d_stop, &'q shrd *h_stop); 

        // let mut h_stop: bool @ cpu.heap = true;
        let mut d_stop: bool @ gpu.global =
            gpu_alloc::<'o, 'p, cpu.stack, cpu.heap, bool>(&'o uniq gpu, &'p shrd *h_stop);
        // copy_to_host::<'u, l, bool>(&'u shrd d_stop, h_stop);

        while *h_stop {

            *h_stop = false;

            // copy_to_gpu::<r: prv, r2: prv, r3: prv, t: ty>(&r uniq cpu.stack Gpu, & r2 uniq gpu.global t, & r3 shrd cpu.heap t): 
            copy_to_gpu::<'m, 't, 'q, bool>(&'m uniq gpu, &'t uniq d_stop, &'q shrd *h_stop); 

            let nodes_view: [[ &'r shrd gpu.global (i32, i32); n]] =
                to_view::<'r, gpu.global, n, (i32, i32)>(&'r shrd nodes);

            let view_changes: [[ &'i uniq gpu.global (bool, bool, bool, i32); n]] =
                to_view_mut::<'i, gpu.global, n, (bool, bool, bool, i32)>(&'i uniq d_changes);

            let zipped_nodes_changes: [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; n ]] =
                zip::<n, &'r shrd gpu.global (i32, i32), &'i uniq gpu.global (bool, bool, bool, i32) >(nodes_view, view_changes);
        
            let grouped_nodes_changes: [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; n/1024]] =
                group::<1024, n, <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32)> >(zipped_nodes_changes);

            //kernel 1
            exec::< 64 , 1024, 'j, cpu.stack,  [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; 64]] >(
                &'j uniq gpu,
                grouped_nodes_changes,
                | grid: Grid<Block<Thread, 1024>, 64>,
                  input: [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; 64]]
                | -[gpu.grid]-> () {
                      for grid with <input> do
                        | block: Block<Thread, 1024>,
                          ib: [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]] 
                        | -[gpu.block]-> () {
                            for block with <ib> do 
                                | thread: Thread,
                                  inp: <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32)> 
                                | -[gpu.thread]-> () {
                                    // do smth for testing
                                    let temp = *inp.0;
                                    let x = temp.0;
                                    () // <== why?
                                    // mask
                                    /*
                                    if *inp.1.0 { // TODO if will not be implemented, but if_else
                                        *inp.1.0 = false;
                                        let node_start = *inp.0.0;
                                        let no_of_edges = *inp.0.1;
                                        for i in node_start..node_start+*no_of_edges {
                                            let id: i32 = *edges_view[i];
                                            // visited
                                            if !*view_changes[i].2 {
                                                // cost = input cost + 1 
                                                *view_changes[i].3 = *inp.1.3 + 1;
                                                *view_changes[i].1 = true; // updating mask 
                                            } else {
                                                ()
                                            }
                                        }
                                    } else {
                                        ()
                                    }
                                    */   
                                };
                        };
                }
            );
            let nodes_view: [[ &'r shrd gpu.global (i32, i32); n]] =
                to_view::<'r, gpu.global, n, (i32, i32)>(&'r shrd nodes);

            let view_changes: [[ &'i uniq gpu.global (bool, bool, bool, i32); n]] =
                to_view_mut::<'i, gpu.global, n, (bool, bool, bool, i32)>(&'i uniq d_changes);

            let zipped_nodes_changes: [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; n ]] =
                zip::<n, &'r shrd gpu.global (i32, i32), &'i uniq gpu.global (bool, bool, bool, i32) >(nodes_view, view_changes);
        
            let grouped_nodes_changes: [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; n/1024]] =
                group::<1024, n, <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32)> >(zipped_nodes_changes);
            //kernel 2 
            exec::<64, 1024, 'j, cpu.stack, [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; 64]]>(
                &'h uniq gpu,
                grouped_nodes_changes,
                | grid: Grid<Block<Thread, 1024>, 64>,
                  input: [[ [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]]; 64]]
                | -[gpu.grid]-> () {

                        for grid with input do
                        | block: Block<Thread, 1024>,
                            ib: [[ <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) >; 1024 ]] 
                        | -[gpu.block]-> () {

                            for block with ib do 
                                | thread: Thread,
                                    inp: <&'r shrd gpu.global (i32, i32),  &'i uniq gpu.global (bool, bool, bool, i32) > 
                                | -[gpu.thread]-> () {
                                    // smth for testing
                                    let other_temp = *inp.0;
                                    let y = other_temp.0;
                                    let z = y;
                                    ()   
                                    // if *inp.1.1 { //updating mask
                                    //     *inp.1.0 = true; // mask
                                    //     *inp.1.2 = true; // visited
                                    //     d_stop = true; //  does not work probably // TODO atomic set 
                                    //     // new type Atomic<bool>
                                    //     *inp.1.1 = false; //updating mask
                                    // } else {
                                    //     ()
                                    // }
                                    };
                            };
                    }
                );
                
            copy_to_host::<'u, l, bool>(&'u shrd d_stop, h_stop);
        }
    }
}