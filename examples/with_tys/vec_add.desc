fn inplace_vector_add<n: nat, a: prv, b: prv>(
    ha_array: &a uniq cpu.mem [i32; n],
    hb_array: &b shrd cpu.mem [i32; n]
) -[t: cpu.thread]-> () <'r, 's, 'c, 'd, 'e, 'f, 'i, 'g, 'h>{
    let mut gpu = gpu_device(0);

    let mut a_array: _ @ gpu.global =
        gpu_alloc_copy::<'c, 'd, [i32; n]>(&'c uniq gpu, &'d shrd *ha_array);
    let b_array: [i32; n] @ gpu.global =
        gpu_alloc_copy::<'f, 'i, [i32; n]>(&'f uniq gpu, &'i shrd *hb_array);
    // exec: <b: nat, t: nat, r: prv, m: mem, elem_ty: ty, n: nat>(
    //        &r uniq m Gpu, [[elem_ty; n]], ([[[[Thread; t]]; b]], [[elem_ty; n]]) -[gpu]-> ()) -> ()
    exec::<64, 1024, 'h, (&'r uniq gpu.global [i32; n], &'s shrd gpu.global [i32; n])>(
        &'h uniq gpu,
        (&'r uniq a_array, &'s shrd b_array),
        | input: (&'r uniq gpu.global [i32; n], &'s shrd gpu.global [i32; n])| -[grid: gpu.grid<X<64>, X<1024>>]-> () {
            let view_a: &'r uniq gpu.global [[i32; n]] =
                to_view_mut::<'r, gpu.global, n, i32>(input.0);
            let view_b: &'s shrd gpu.global [[i32; n]] =
                to_view::<'s, gpu.global, n, i32>(input.1);
            let grouped_a: &'r uniq gpu.global [[ [[i32; 1024]]; n/1024]] =
                group_mut::<1024, 'r, gpu.global, n, i32>(view_a);
            let grouped_b: &'s shrd gpu.global [[ [[i32; 1024]]; n/1024]] =
                group::<1024, 's, gpu.global, n, i32>(view_b);
            sched block in grid <'rb, 'sb>{
                let a_row: &'rb uniq gpu.global [[i32; 1024]] = grouped_a[['rb block]];
                let b_row: &'sb shrd gpu.global [[i32; 1024]] = grouped_b[['sb block]];
                sched thread in block <'rt, 'st>{
                    let a: &'rt uniq gpu.global i32 = a_row[['rt thread]];
                    let b: &'st shrd gpu.global i32 = b_row[['st thread]];
                    *a = *a + *b
                }
            }
        }
    );
    copy_to_host::<'g, a, [i32; n]>(&'g shrd a_array, ha_array)
}
