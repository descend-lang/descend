fn reduce_shared_mem<n: nat, a: prv, b: prv>(
    ha_array: &a shrd cpu.heap [i32; n],
    h_output: &b uniq cpu.heap [i32; 64]
) -[cpu.thread]-> () <'r, 'c, 'd, 'e, 'f, 'g, 'h, 'm, 'u1, 'u2>{
    let mut gpu: Gpu = gpu_device(0);

    let a_array = gpu_alloc_copy::<'c, a, cpu.stack, cpu.heap, [i32; n]>(&'c uniq gpu, ha_array);
    let mut out_array = gpu_alloc_copy::<'c, 'm, cpu.stack, cpu.heap, [i32; 64]>(&'c uniq gpu, &'m shrd *h_output);
    let view_a = to_view::<'r, gpu.global, n, i32>(&'r shrd a_array);
    let block_group = group::<1024, 'r, gpu.global, n, i32>(view_a);
    let view_out = group_mut::<1, 'm, gpu.global, 64, i32>(to_view_mut::<'m, gpu.global, 64, i32>(&'m uniq out_array));
    exec::<64, 1024, 'h, cpu.stack, <&'r shrd gpu.global [[[[i32; 1024]]; 64]], &'m uniq gpu.global [[[[i32; 1]]; 64]]>>(
        &'h uniq gpu,
        <block_group, view_out>,
        | grid: BlockGrp<64, ThreadGrp<1024>>,
          views: <&'r shrd gpu.global [[[[i32; 1024]]; 64]], &'m uniq gpu.global [[[[i32; 1]]; 64]]>| -[gpu.grid]-> () <>{
            let block_group = views.0;
            let view_out = views.1;

            // TODO remove decl and move out tmp declaration
            decl {
                let mut tmp: [i32; 1024] @ gpu.shared
            } parfor block in grid with ib, out_elem from block_group, view_out {
                 let tmp_view = to_view_mut::<'e, gpu.shared, 1024, i32>(&'e uniq tmp);
                 parfor block
                 with inp, tmp_in from ib, tmp_view { *tmp_in = *inp };

                 for_nat k in halved_range(512) <'s, 'r1, 'r2, 's1, 's2>{
                    let tmp_view = to_view_mut::<'s, gpu.shared, 1024, i32>(&'s uniq tmp);
                    let split_tmp_view = (split 'r1 'r2 uniq 2*k tmp_view).0;
                    let active_halves = split 's1 's2 uniq k split_tmp_view;

                    let active_half0 = active_halves.0;
                    let active_half1 = active_halves.1;

                    // Fixme: At thies point 's1 -> {tmp, split_tmp_view, tmp_view, tmp}
                    parfor split_thread_grp::<k, 1024, 1, 1>(block).0
                    with a, b from active_half0, active_half1 {
                        *a = *a + *b
                    }
                 };
                 let tmp_view2 = to_view_mut::<'f, gpu.shared, 1024, i32>(&'f uniq tmp);
                 let tmp_res = (split 'u1 'u2 uniq 1 tmp_view2).0;
                 parfor split_thread_grp::<1, 1024, 1, 1>(block).0
                 with out, tmp_val from out_elem, tmp_res {
                    *out = *tmp_val
                 }
             }
        }
    );
    // Todo
    //  There is no check for n == 64 (which is NOT the case). Therefore it is wrong to specify
    //  [i32; n] as the array type. However, this still type checks.
    copy_to_host::<'g, b, cpu.heap, [i32; 64]>(&'g shrd out_array, h_output)
}