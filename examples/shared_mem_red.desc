fn reduce_shared_mem<n: nat, a: prv, b: prv>(
    ha_array: &a shrd cpu.heap [i32; n],
    h_output: &b uniq cpu.heap [i32; 64]
) -[cpu.thread]-> () {
    letprov <'r, 'c, 'd, 'e, 'f, 'g, 'h, 'm, 'u1, 'u2> {
        let mut gpu: Gpu = gpu_device(0);

        let a_array: [i32; n] @ gpu.global =
            gpu_alloc::<'c, a, cpu.stack, cpu.heap, [i32; n]>(&'c uniq gpu, ha_array);
        let mut out_array: [i32; 64] @ gpu.global =
            gpu_alloc::<'c, 'm, cpu.stack, cpu.heap, [i32; 64]>(&'c uniq gpu, &'m shrd *h_output);
        let view_a: &'r shrd gpu.global [[i32; n]] =
            to_view::<'r, gpu.global, n, i32>(&'r shrd a_array);
        let view_out: &'m uniq gpu.global [[[[i32; 1]]; 64]] =
            group_mut::<1, 'm, gpu.global, 64, i32>(to_view_mut::<'m, gpu.global, 64, i32>(&'m uniq out_array));
        let block_group = group::<1024, 'r, gpu.global, n, i32>(view_a);
        exec::<64, 1024, 'h, cpu.stack, <&'r shrd gpu.global [[[[i32; 1024]]; 64]], &'m uniq gpu.global [[[[i32; 1]]; 64]]>>(
            &'h uniq gpu,
            <block_group, view_out>,
            | grid: BlockGrp<64, ThreadGrp<1024>>,
              views: <&'r shrd gpu.global [[[[i32; 1024]]; 64]], &'m uniq gpu.global [[[[i32; 1]]; 64]]>| -[gpu.grid]-> () {
                let input = views.0;
                let output = views.1;
                let mut tmp: [i32; 1024] @ gpu.shared = shared_alloc::<[i32; 1024]>();
                for grid with <input, output, tmp> do
                    | block: ThreadGrp<1024>,
                      ib: &'r shrd gpu.global [[i32; 1024]],
                      out_elem: &'m uniq gpu.global [[i32; 1]],
                      mut tmpb: [i32; 1024] @ gpu.shared
                    | -[gpu.block]-> () {
                         let tmp_view: &'e uniq gpu.shared [[i32; 1024]] =
                            to_view_mut::<'e, gpu.shared, 1024, i32>(&'e uniq tmpb);
                         for block
                         with <ib, tmp_view>
                         do
                            |
                              inp: &'r shrd gpu.global i32 , tmp_in: &'e uniq gpu.shared i32
                            | -[gpu.thread]-> () {
                                 *tmp_in = *inp
                            };
                         for_nat k in halved_range(512) {
                            letprov<'s, 'r1, 'r2, 's1, 's2> {
                                let tmpb_view = to_view_mut::<'s, gpu.shared, 1024, i32>(&'s uniq tmpb);
                                let split_tmpb_view = (split 'r1 'r2 uniq 2*k tmpb_view).0;
                                let active_halves: <&'s1 uniq gpu.shared [[i32; k]], &'s2 uniq gpu.shared [[i32; 2*k-k]]> =
                                    split 's1 's2 uniq k split_tmpb_view;

                                for split_thread_grp::<k, 1024, 1, 1>(block).0
                                with active_halves
                                do
                                    |
                                      a: &'s1 uniq gpu.shared i32, b: &'s2 uniq gpu.shared i32
                                    | -[gpu.thread]-> () {
                                        *a = *a + *b
                                    }
                            }
                         };
                         let tmpb_view2 = to_view_mut::<'f, gpu.shared, 1024, i32>(&'f uniq tmpb);
                         let tmp_res = (split 'u1 'u2 uniq 1 tmpb_view2).0;
                         for split_thread_grp::<1, 1024, 1, 1>(block).0
                         with <out_elem, tmp_res>
                         do
                            |
                              out_elem: &'m uniq gpu.global i32 , tmp_val: &'u1 uniq gpu.shared i32
                            | -[gpu.thread]-> () {
                                *out_elem = *tmp_val
                            }
                     }
            }
        );
        // Todo
        //  There is no check for n == 64 (which is NOT the case). Therefore it is wrong to specify
        //  [i32; n] as the array type. However, this still type checks.
        copy_to_host::<'g, b, cpu.heap, [i32; 64]>(&'g shrd out_array, h_output)
    }
}