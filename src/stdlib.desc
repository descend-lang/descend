trait Copy {}

trait Number: Copy {}

trait Add<RHS, OUTPUT> {
    fn add(Self, RHS) -[gpu.thread]-> OUTPUT;
}

trait Eq {
    fn eq(Self, Self) -[gpu.thread]-> bool;
}


impl<T> Copy for T where T: Number {}
impl Copy for bool {}
impl Copy for Gpu {}
impl Copy for () {}
impl Copy for Atomic<i32> {}
impl Copy for Atomic<bool> {}
impl<T, a: prv, m: mem> Copy for &a shrd m T {}
impl<T, n: nat> Copy for [T; n] where T: Copy {}

impl Number for f32 {}
impl Number for f64 {}
impl Number for i32 {}
impl Number for u32 {}

impl<T> Add<T, T> for T where T: Number {
    fn add(t1: T, t2: T) -[gpu.thread]-> T {
        __add_internal(t1, t2)
    }
}

impl<T> Eq for T where T: Number {
    fn eq(t1: T, t2: T) -[gpu.thread]-> bool {
        __eq_internal(t1, t2)
    }
}

impl<X, a: prv, m: mem> Eq for &a shrd m X where X: Eq + Copy {
    fn eq(t1: Self, t2: Self) -[gpu.thread]-> bool {
        let t1_d = *t1;
        let t2_d = *t2;
        X::eq(t1_d, t2_d)
    }
}
