trait Copy {}

trait Number: Copy {}

trait Add<RHS, OUTPUT> {
    fn add(Self, RHS) -[gpu.thread]-> OUTPUT;
}

trait Eq {
    fn eq(Self, Self) -[gpu.thread]-> bool;
}


impl<T> Copy for T where T: Number {}
impl Copy for bool {}
impl Copy for Gpu {}
impl Copy for () {}
impl Copy for Atomic<i32> {}
impl Copy for Atomic<bool> {}
impl<T, a: prv, m: mem> Copy for &a shrd m T {}
impl<T, n: nat> Copy for [T; n] where T: Copy {}

impl Number for f32 {}
impl Number for f64 {}
impl Number for i32 {}
impl Number for u32 {}

impl<T> Add<T, T> for T where T: Number {
    fn add(t1: T, t2: T) -[gpu.thread]-> T {
        __add_internal(t1, t2)
    }
}

impl<T> Eq for T where T: Number {
    fn eq(t1: T, t2: T) -[gpu.thread]-> bool {
        __eq_internal(t1, t2)
    }
}

impl<T, a: prv, m: mem> Eq for &a shrd m T where T: Eq + Copy {
    fn eq(t1: Self, t2: Self) -[gpu.thread]-> bool {
        T::eq(*t1, *t2)
    }
}
